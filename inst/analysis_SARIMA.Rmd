---
title: "Fitted SARIMA Model"
author: "BETS Package"
date: "`r Sys.Date()`"
output: html_document
params:
  ts: 21864
  series.file: !r NA
  lag.max: 48
  n.ahead: 12
  ur.test: !r list(mode = "ADF", type = "drift", lags = 11, selectlags = "AIC", level = "5pct")
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)

custom.ts = TRUE
ts = params$ts

if(class(ts) != 'ts'){
  custom.ts = FALSE
  code = as.integer(ts) 
} else{
  code = "None"
}

series.file = params$series.file
```

## User-Defined Parameters

 Parameter          | Value              | Variable
 ------------------ | ------------------ | ----------
 Series Code        | `r code`           | `ts` 
 Maximum Lag        | `r params$lag.max` | `lag.max` 
 Prevision Horizon  | `r params$n.ahead` | `n.ahead` 
 Unit Root Test     | `r params$ur.test` | `ur.test` 

 
```{r echo = FALSE}
  lag.max = params$lag.max
  n.ahead = params$n.ahead
  ur.test = params$ur.test
```

```{asis echo = !custom.ts}
## Getting the Time Series from the BETS database
```

```{r eval = !custom.ts, echo = !custom.ts}
library(BETS)
data = BETS.get(code)
```

### Information About the Series

```{r eval = !custom.ts, echo = !custom.ts}
info <- BETS.search(code = ts, view = F)
print(params$teste)
```

```{r eval = custom.ts, echo = custom.ts}
data <- ts
```

```{r echo = FALSE, eval = custom.ts}
info <- data.frame(matrix(nrow = 1, ncol = 6))
names(info) <- c("Code","Description","Periodicity","Start","Source","Unit")
info[1,] <- c(code," ",frequency(data),paste0(start(data),collapse = "."),"Custom"," ")
```

```{r echo = FALSE, eval = !custom.ts}
names(info) <- c("Code","Description","Periodicity","Start","Source","Unit")
info[,"Start"] <- paste(start(data),collapse=".")
info[,"Description"] <- trimws(info[,"Description"])
```

```{r echo = FALSE}
knitr::kable(info, format = "markdown")
```


## Graph

```{r echo = F}
library(mFilter)
```


```{r eval = -1}
library(mFilter)
trend = fitted(hpfilter(data))

library(dygraphs)
dygraph(cbind(Series = data, Trend = trend), main = info[,"Description"]) %>%
  dyRangeSelector(strokeColor = "gray", fillColor = "gray") %>%
    dyAxis("y", label = info[,"Unit"]) 
```

## Unit Root Tests

```{asis eval = (ur.test == "ADF")}
### Augmented Dickey-Fuller 
```


```{asis eval = (ur.test == "KPSS")}
### KPSS
```

```{asis eval = (ur.test == "PP")}
### Phillips-Perron
```

```{r}
  test.params = append(list(y = data), ur.test)
  df = do.call(BETS.ur_test,test.params)
  df$results
```

```{r echo = F}
lvl = ur.test$level
if(lvl == "1pc"){
    ic = "99%"
    alpha = 0.01
} else if(lvl == "2.5%"){
    ic = "97.5%"
    alpha = 0.025
} else if(lvl == "5%"){
    ic = "95%"
    alpha = 0.05
} else {
    ic = "90%"
    alpha = 0.1
}
```


```{r eval = (ur.test$mode != "KPSS"), echo = FALSE}
  uroot = FALSE
  uroot = (df$results[1,"statistic"] < df$results[1,"crit.val"])
```

```{asis eval = (ur.test$mode != "KPSS") && uroot}
  For a 95% confidence interval, the test statistic `tau3` is greater than the critical value. We therefore conclude that there must be a unit root. 
```

```{r eval = (ur.test$mode == "KPSS"), echo = FALSE}
  uroot = FALSE
  uroot = (df$results[1,"statistic"] > df$results[1,"crit.val"])
```

```{asis eval = (ur.test$mode == "KPSS") && uroot}
  For a 95% confidence interval, the test statistic `tau3` is smaller than the critical value. We therefore conclude that there must be a unit root. 

```

```{asis eval = uroot}
  Now, we are going to repeatedly apply `diff` to the series and check if the diferenced series has a unit root.
```

```{asis eval = !uroot}
  For a 95% confidence interval, the test statistic `tau3` is smaller than the critical value. We therefore conclude that there is no unit root. 
```

```{r eval = uroot, echo = uroot}
  ns_roots = 0
  d_ts = data 

  while(df$results[1,"statistic"]> df$results[1,"crit.val"]){
    ns_roots = ns_roots + 1
    d_ts = diff(d_ts)
    test.params = append(list(y = d_ts), ur.test)
    df = do.call(BETS.ur_test,test.params)
    print(df$results)
 }
```
`r if(uroot) 'These tests found that there must be a total of '` `r if(uroot) ns_roots` `r if(uroot) ' unit root(s)'`

### Osborn-Chui-Smith-Birchenhall

This test will be performed for lag `r frequency(data)`, that is, the frequency of the series `r info[1,1]`. 

```{r echo = c(1,2,3)}
library(forecast)
s_roots = nsdiffs(data)
print(s_roots)

sroot = FALSE
if(s_roots != 0) sroot = TRUE
roots = (uroot || sroot)
```

```{asis eval = !sroot}
  According to the OCSB test, there is no seasonal unit root, at least at a 5% significance level. 
```

`r if(sroot) 'This result holds for a 5% signficance level and means that, according to the OCSB test, there must be a total of '` `r if(sroot) s_roots` `r if(sroot) ' seasonal unit root(s)'`

## Auto-Correlation Functions

```{r echo = FALSE}
library(plotly)
```

```{asis eval = !roots, echo = !roots }
### ACF and PACF - Original Series
```

```{asis eval = roots, echo = roots}
### ACF and PACF - After Differencing
```

`r if(roots) 'As we saw earlier, this series probably has'` `r if(uroot) ns_roots` `r if(uroot) ' non-seasonal unit root(s)'` `r if(sroot && uroot) ' and '` `r if(sroot) s_roots` `r if(sroot) ' seasonal unit root(s)'` `r if(roots) '. It means we have look into the correlograms of the differenced series.'`

```{r eval =  sroot, echo = sroot}
for(i in 1:s_roots){
  d_ts <- diff(d_ts, frequency(data))
}
```

```{r eval = !roots, echo = !roots}
d_ts <- data
```

```{r fig.height=2, fig.width=4.5}
BETS.corrgram(d_ts, lag.max = lag.max, mode = "bartlett", knit = T)
BETS.corrgram(d_ts, lag.max = lag.max, mode = "simple", type = "partial", knit = T)
```

## Model Identification and Estimation

The correlograms from last section gives us enough information to try to identify the underlying SARIMA model parameters. We can confirm our guess by running the `auto.arima` function from the package `forecast`. By default, this function uses the AICc (Akaike Information Criterion with Finite Sample Correction) for model selection. Here, we are going to use BIC (Bayesian Information Criterion), in which the penalty term for the number of parameters in the model is larger than in AIC.


```{r echo = c(1,2)}
model = auto.arima(data, ic = "bic", test = tolower(ur.test$mode), max.d = ns_roots, max.D = s_roots)
summary(model)

desc = capture.output(model)[2]
diffs = as.numeric(gsub("\\,", "", regmatches(desc,gregexpr(",.,",desc))[[1]]))

p = model$arma[1]
d = diffs[1]
q = model$arma[2]
P = model$arma[3]
D = diffs[2]
Q = model$arma[4]
freq = model$arma[5]
```

We see that, according to BIC, the best model is a `r desc`.

## Forecasts

```{r}
BETS.predict(model,h=n.ahead, main = info[,"Description"], ylab = info[,"Unit"], knit = T)
```


```{r echo = F, eval = !is.na(series.file)}
preds = BETS.predict(model,h=n.ahead, main = info[,"Description"], ylab = info[,"Unit"], knit = F)
data = c(data,preds$mean)

if(grepl("\\.spss$", series.file)){
  BETS.save.spss(file.name = gsub("\\.spss$", "", series.file), data = data)
} else if(grepl("\\.dta$", series.file)){
  BETS.save.stata(file.name = gsub("\\.dta$", "", series.file), data = data)
} else if(grepl("\\.sas$", series.file)){
  BETS.save.sas(file.name = gsub("\\.sas$", "", series.file), data = data)
}else if(grepl("\\.csv$", series.file)) {
  write.csv(data, file = series.file, row.names = F)
} else if(grepl("\\.csv2$", series.file)) {
  series.file = gsub("\\.csv2$", ".csv", series.file)
  write.csv2(data, file = series.file, row.names = F)
}
```

<br>
`r if(!is.na(series.file)) 'The whole series and the model predictions are available at [THIS LINK]('``r if(!is.na(series.file)) series.file``r if(!is.na(series.file)) ')'`

